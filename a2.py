# -*- coding: utf-8 -*-
"""A2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m9zPIjtnbmfmYF80hGzVJyL2CcNytGDV

## Importing Libraries
"""

import cv2
import numpy as np

#libraries for local max
import scipy.ndimage.filters as filters
import scipy.ndimage as ndimage
from skimage.feature import peak_local_max

"""##Load image from url"""

# image_path = tf.keras.utils.get_file('image.png', 'https://raw.githubusercontent.com/ozgunsungar/Corner-Edge_Detection/main/image.png', cache_subdir="/content/")
!wget -O image.png https://raw.githubusercontent.com/ozgunsungar/Corner-Edge_Detection/main/image.png

"""##Generic Sobel Function 
***Same as A1 assignment***
"""

def generalized_sobel(n):

  sobelx = cv2.getDerivKernels(1, 0, n)
  sobelx = np.outer(sobelx[0], sobelx[1])
  sobelx =sobelx/np.sum(np.absolute(sobelx))
  
  sobely = cv2.getDerivKernels(0, 1, n)
  sobely = np.outer(sobely[0], sobely[1])
  sobely =sobely/np.sum(np.absolute(sobely))

  m = np.array([sobelx,sobely])
 
  print("Sobelx = \n",sobelx)
  print("Sobely = \n",sobely)
  return m

"""##Conolution Function 
***Same as A1 assignment***
"""

def my_conv(img, kernel):

  print("Conv kernel type",type(kernel))
  print("Conv kernel shape",kernel.shape)
  n = kernel.shape[0]
  w, h = img.shape[1], img.shape[0]
  filter_img = np.array([[0 for x in range(w)] for y in range(h)])
  # write your convolution function
  for i in range(0,img.shape[0]-(n-1)):
    for j in range(0, img.shape[1]-(n-1)):
      if i > img.shape[0] or j >img.shape[1]:
        continue 

      # filter_img[i][j]= np.sum((img[i:i+3, j:j+3])*np.divide(kernel,8))
      filter_img[i][j]= np.sum((img[i:i+n, j:j+n])*kernel)

  # print("filter_img type",type(filter_img))

  #Alternative way
  # m, n = kernel.shape
  # if (m == n):
  #     y, x = img.shape
  #     y = y - m + 1
  #     x = x - m + 1
  #     filter_img = np.zeros((y,x))
  #     for i in range(y):
  #         for j in range(x):
  #             filter_img[i][j] = np.sum(img[i:i+m, j:j+m]*(kernel)) 

  return filter_img

"""##OrietColor Function 
***Same as A1 assignment***
"""

def find_img_orient(sx,sy):
  # theta = np.arctan2(sx, sy)
  magnitude = np.sqrt((sx ** 2) + (sy ** 2))
  theta =  np.arctan2(sx, sy) * (180 / np.pi) % 180  #theta = orient
  theta = theta*2.
# print("max theta : ",np.amax(theta))
  #mag = cv2.magnitude(sx, sy)
  thresh = 18
  _, mask = cv2.threshold(magnitude, thresh, 255, cv2.THRESH_BINARY)

  # I used OpenCV imshow instead of matplotlib, so the colors are in BGR (use yours)
  red = np.array([0, 0, 255])
  cyan = np.array([255, 255, 0])
  green = np.array([0, 255, 0])
  yellow = np.array([0, 255, 255])

  # for the same reason I use np.uint8
  image_map = np.zeros((theta.shape[0], theta.shape[1], 3), dtype=np.uint8)
  print("Theta = ",theta)
  # setting the colors, maybe there is a better way, my numpy skills are rusty
  # it checks that magnitude is above the threshold and that the orientation is in range
  image_map[ (mask == 255) & (theta < 45) ] = red
  image_map[(mask == 255) & (theta > 45) & (theta < 90)] = cyan
  image_map[(mask == 255) & (theta > 90) & (theta < 135)] = green
  image_map[(mask == 255) & (theta > 135)] = yellow

  return image_map

"""##Hysteresis with double threshold

"""

def double_threshold_hysteresis(image, low, high):
    weak = 50
    strong = 255
    size = image.shape
    result = np.zeros(size)
    weak_x, weak_y = np.where((image > low) & (image <= high))
    strong_x, strong_y = np.where(image >= high)
    result[strong_x, strong_y] = strong
    result[weak_x, weak_y] = weak
    dx = np.array((-1, -1, 0, 1, 1, 1, 0, -1))
    dy = np.array((0, 1, 1, 1, 0, -1, -1, -1))
    size = image.shape
    
    while len(strong_x):
        x = strong_x[0]
        y = strong_y[0]
        strong_x = np.delete(strong_x, 0)
        strong_y = np.delete(strong_y, 0)
        for direction in range(len(dx)):
            new_x = x + dx[direction]
            new_y = y + dy[direction]
            if((new_x >= 0 & new_x < size[0] & new_y >= 0 & new_y < size[1]) and (result[new_x, new_y]  == weak)):
                result[new_x, new_y] = strong
                np.append(strong_x, new_x)
                np.append(strong_y, new_y)
    result[result != strong] = 0
    return result

"""## Non-max"""

def non_maximum_suppression(image, angles):
    size = image.shape
    suppressed = np.zeros(size)
    for i in range(1, size[0] - 1):
        for j in range(1, size[1] - 1):
            if (0 <= angles[i, j] < 22.5) or (157.5 <= angles[i, j] <= 180):
                value_to_compare = max(image[i, j - 1], image[i, j + 1])
            elif (22.5 <= angles[i, j] < 67.5):
                value_to_compare = max(image[i - 1, j - 1], image[i + 1, j + 1])
            elif (67.5 <= angles[i, j] < 112.5):
                value_to_compare = max(image[i - 1, j], image[i + 1, j])
            else:
                value_to_compare = max(image[i + 1, j - 1], image[i - 1, j + 1])
            
            if image[i, j] >= value_to_compare:
                suppressed[i, j] = image[i, j]
    suppressed = np.multiply(suppressed, 255.0 / suppressed.max())
    return suppressed

"""## Harris"""

def harris(img,dx,dy): #img = colorful image
    
    img_copy = np.copy(img)
    # square of derivatives
    dx2 = np.float32(np.square(dx))
    dy2 = np.float32( np.square(dy))
    dxdy= np.float32(np.multiply(dx,dy)) #cross filtering
    
    # gauss filter for all directions (x,y,cross axis)
    g_dx2 = cv2.GaussianBlur(dx2,(19,19),0)
    g_dy2 = cv2.GaussianBlur(dy2,(19,19),0)
    g_dxdy = cv2.GaussianBlur(dxdy,(19,19),0)

    # Harris Function
    # r(harris) = det - k*(trace**2) where 0.04 < k < 0.06
    harris =np.multiply( g_dx2,g_dy2) - np.square(g_dxdy) - 0.05*np.square(g_dx2 + g_dy2) 
    cv2.imwrite("img_harris.png",harris)
    
    return img_copy,harris

"""## Finding corners on image"""

def corner_localmax(img,harris):
  neighborhood_size = 4
  threshold = 400

  data = harris
  img_copy = np.copy(img)
  data_max = filters.maximum_filter(data, neighborhood_size)
  maxima = (data == data_max)
  data_min = filters.minimum_filter(data, neighborhood_size)
  diff = ((data_max - data_min) > threshold)
  maxima[diff == 0] = 0

  labeled, num_objects = ndimage.label(maxima)
  slices = ndimage.find_objects(labeled)
  for dy,dx in slices:
      x_center = (dx.start + dx.stop - 1)//2
      y_center = (dy.start + dy.stop - 1)//2    
      img_copy = cv2.circle(img_copy, (x_center,y_center), 2, (0,0,255), -1)

    
  return img_copy

"""## Main function"""

def main():

  sobel = generalized_sobel(3)
  Gx = sobel[0]
  Gy = sobel[1]
  # read image
  img = cv2.imread("image.png",0)
  img2 = cv2.imread("image.png")
  blur = cv2.GaussianBlur(img,(3,3),0)
  

  sx = my_conv(blur,Gx)
  sy = my_conv(blur,Gy)

  sx = np.absolute(sx)
  sy = np.absolute(sy)
  
  image_grad = np.add(sx,sy)
  
  G = np.hypot(sx, sy)
  img_orient = find_img_orient(sx,sy)


  # writes image to a file
  cv2.imwrite("image_sx.png",sx)
  cv2.imwrite("image_sy.png",sy)
  cv2.imwrite("image_grad.png",G)
  cv2.imwrite("image_orient.png",img_orient)

  #A2 Assignment
  angles = np.rad2deg(np.arctan2(sx, sy))
  angles[angles < 0] += 180
  img_canny = non_maximum_suppression(G, angles)
  # gradient = np.copy(image)
  low = 0
  high = 50
  img_canny = double_threshold_hysteresis(img_canny, low, high)
  cv2.imwrite("image_canny.png",img_canny)

  _,img_harris = harris(img2,sx,sy)
  img_corners = corner_localmax(img2,img_harris)
  cv2.imwrite("image_corners.png",img_corners)

if __name__ == "__main__":
    main()